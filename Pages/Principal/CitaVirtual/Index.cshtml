@page
@model mecanico_plus.Pages.Principal.CitaVirtual.IndexModel

@{
    if (Model.IsAnonymousUser)
    {
        Layout = "_AnonymousLayout";
    }
    ViewData["Title"] = "Citas Virtuales - Chat y Videollamada";
}

<!-- Initial Options Section -->
<div id="initialOptions" class="min-h-screen bg-gray-100 p-4">
    <div class="max-w-md mx-auto space-y-4">
        <div class="bg-white p-6 rounded-lg shadow-lg text-center space-y-4">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">Cita Virtual</h2>
            <button id="generateBtn" class="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors">
                <i class="fas fa-plus-circle mr-2"></i>Generar Nueva Cita
            </button>
            <div class="relative">
                <div class="absolute inset-0 flex items-center">
                    <div class="w-full border-t border-gray-300"></div>
                </div>
                <div class="relative flex justify-center text-sm">
                    <span class="px-2 bg-white text-gray-500">O</span>
                </div>
            </div>
            <button id="joinBtn" class="w-full bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-colors">
                <i class="fas fa-sign-in-alt mr-2"></i>Entrar a Cita Existente
            </button>
        </div>
    </div>
</div>

<!-- Token Input Dialog -->
<div id="tokenDialog" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden flex items-center justify-center">
    <div class="bg-white p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
        <h3 class="text-xl font-semibold mb-4">Ingrese el Token de la Cita</h3>
        <input type="text" id="tokenInput" 
               class="w-full px-4 py-2 border rounded-lg mb-4 focus:outline-none focus:border-blue-500"
               placeholder="Ingrese el token de la cita">
        <div class="flex justify-end space-x-2">
            <button id="cancelJoin" class="px-4 py-2 text-gray-600 hover:text-gray-800">
                Cancelar
            </button>
            <button id="confirmJoin" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                Entrar
            </button>
        </div>
    </div>
</div>

<!-- Main Chat and Video Section -->
<div id="mainContent" class="hidden">
    <!-- Room Token Display - New Floating Button and Panel -->
    <button id="tokenToggleBtn" 
            class="fixed bottom-6 left-6 bg-blue-600 text-white p-4 rounded-full shadow-lg hover:bg-blue-700 transition-all z-50 token-toggle-btn">
        <i class="fas fa-key text-xl"></i>
    </button>

    <div id="tokenPanel" 
         class="fixed left-0 top-0 h-auto w-96 bg-white shadow-lg transform -translate-x-full transition-transform duration-300 ease-in-out z-40">
        <div class="p-4 bg-blue-600 text-white flex justify-between items-center">
            <h2 class="text-xl font-semibold">Token de la Sala</h2>
            <button id="closeTokenBtn" class="text-white hover:text-gray-200">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="p-4">
            <div class="flex items-center space-x-2">
                <span class="text-blue-600 font-semibold break-all">@Model.RoomToken</span>
                <button id="copyTokenBtn" class="p-2 text-gray-600 hover:text-blue-600 transition-colors">
                    <i class="fas fa-copy"></i>
                </button>
            </div>
            <p class="text-sm text-gray-600 mt-2">
                Comparte este token para que otros puedan unirse a la cita virtual.
            </p>
        </div>
    </div>

    <div class="min-h-screen bg-gray-100 p-4 relative">
        <!-- Video Container - Ahora directo sin el contenedor extra -->
        <div id="videoContainer" class="relative w-full transition-all duration-300 ease-in-out">
            <!-- Local Video -->
            <div id="localVideoContainer" class="w-full transition-all duration-300 ease-in-out">
                <video id="localVideo" 
                       class="w-full h-screen bg-black object-cover"
                       autoplay playsinline muted></video>
                <div class="absolute bottom-4 left-4 bg-black bg-opacity-50 text-white px-3 py-1 rounded-lg">
                    Tu video
                </div>
                <!-- Fullscreen button moved inside video container -->
                <button id="fullscreenBtn" 
                        class="absolute bottom-4 right-4 bg-black bg-opacity-50 text-white p-2 rounded-lg hover:bg-opacity-75 transition-all">
                    <i class="fas fa-expand text-xl"></i>
                </button>
            </div>

            <!-- Remote Video -->
            <div id="remoteVideoContainer" class="hidden w-full transition-all duration-300 ease-in-out">
                <video id="remoteVideo" 
                       class="w-full h-screen bg-black object-cover"
                       autoplay playsinline></video>
                <div class="absolute bottom-4 left-4 bg-black bg-opacity-50 text-white px-3 py-1 rounded-lg">
                    Video remoto
                </div>
            </div>
        </div>

        <!-- Floating Buttons -->
        <!-- Remove duplicate fullscreen button -->
        <button id="startCallBtn" 
                class="fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-green-500 text-white px-6 py-3 rounded-lg hover:bg-green-600 transition-colors z-50 flex items-center">
            <i class="fas fa-video mr-2"></i>
            <span>Iniciar Videollamada</span>
        </button>
        <button id="stopCallBtn" 
                class="fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-red-500 text-white px-6 py-3 rounded-lg hover:bg-red-600 transition-colors z-50 hidden flex items-center">
            <i class="fas fa-phone-slash mr-2"></i>
            <span>Terminar Videollamada</span>
        </button>

        <!-- Chat Toggle Button - Fixed at bottom right -->
        <button id="chatToggleBtn" 
                class="fixed bottom-6 right-[calc(384px+1.5rem)] bg-blue-600 text-white p-4 rounded-full shadow-lg hover:bg-blue-700 transition-all z-50 chat-toggle-btn">
            <i class="fas fa-comments text-xl"></i>
            <span id="unreadBadge" class="hidden absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full w-6 h-6 flex items-center justify-center">0</span>
        </button>

        <!-- Chat Panel - Slideable from right -->
        <div id="chatPanel" 
             class="fixed right-0 top-0 h-full w-96 bg-white shadow-lg transform translate-x-full transition-transform duration-300 ease-in-out z-40">
            <div class="flex flex-col h-full">
                <div class="p-4 bg-blue-600 text-white flex justify-between items-center">
                    <h2 class="text-xl font-semibold">Chat de Consulta</h2>
                    <button id="closeChatBtn" class="text-white hover:text-gray-200">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="chat-box" class="flex-1 p-4 overflow-y-auto space-y-2"></div>
                <div class="border-t p-4 bg-gray-50">
                    <div class="flex space-x-2">
                        <input id="chat-input" 
                               class="flex-1 rounded-lg border border-gray-300 px-4 py-2 focus:outline-none focus:border-blue-500"
                               placeholder="Escribe un mensaje..." />
                        <button id="send-btn" 
                                class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors">
                            Enviar
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    /* Custom scrollbar for chat */
    #chat-box::-webkit-scrollbar {
        width: 6px;
    }

    #chat-box::-webkit-scrollbar-track {
        background: #f1f1f1;
    }

    #chat-box::-webkit-scrollbar-thumb {
        background: #cbd5e0;
        border-radius: 3px;
    }

    #chat-box::-webkit-scrollbar-thumb:hover {
        background: #a0aec0;
    }

    /* Message styles */
    #chat-box > div {
        padding: 0.75rem;
        border-radius: 0.5rem;
        max-width: 80%;
        word-break: break-word;
    }

    #chat-box > div:nth-child(odd) {
        background-color: #ebf8ff; /* bg-blue-100 */
        margin-left: auto; /* ml-auto */
    }

    #chat-box > div:nth-child(even) {
        background-color: #f7fafc; /* bg-gray-100 */
    }

    .sent-by-me {
        background-color: #ebf8ff !important;
        margin-left: auto !important;
        margin-right: 0 !important;
    }

    #chatPanel {
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
    }

    #chatToggleBtn {
        transition: transform 0.3s ease;
    }

    #chatToggleBtn:hover {
        transform: scale(1.1);
    }

    .chat-open #chatPanel {
        transform: translateX(0);
    }

    /* Ajuste para el botón de chat */
    .chat-toggle-btn {
        transition: right 0.3s ease;
        right: 24px; /* Posición inicial a la derecha */
    }

    /* Cuando el chat está abierto, mover el botón a la izquierda */
    .chat-open .chat-toggle-btn {
        right: 400px; /* Mover el botón fuera del panel de chat cuando está abierto */
    }

    /* Asegurarse de que el panel de chat tenga el ancho correcto */
    #chatPanel {
        width: 384px; /* w-96 */
        z-index: 41; /* Un nivel más alto que el botón de chat */
    }

    /* Estilos para el contenedor de video */
    #videoContainer {
        min-height: calc(100vh - 2rem); /* Altura total menos el padding */
    }

    /* Clase para cuando hay dos videos activos */
    #videoContainer.split-view {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
    }

    /* Animaciones para los contenedores de video */
    #localVideoContainer, #remoteVideoContainer {
        transform-origin: center;
        transition: all 0.3s ease-in-out;
    }

    /* Ajustes para video local cuando está en modo picture-in-picture */
    .pip-mode #localVideoContainer {
        position: absolute;
        width: 320px; /* Aumentar un poco el tamaño */
        height: 240px;
        bottom: 2rem;
        right: 2rem;
        z-index: 10;
        border-radius: 0.5rem;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .pip-mode #localVideo {
        height: 240px;
    }

    /* Estilos para el panel de token */
    #tokenPanel {
        box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
    }

    #tokenToggleBtn {
        transition: transform 0.3s ease;
        left: 24px; /* Posición fija */
    }

    #tokenToggleBtn:hover {
        transform: scale(1.1);
    }

    .token-open #tokenPanel {
        transform: translateX(0);
    }

    /* Eliminar el estilo que mueve el botón */
    .token-open #tokenToggleBtn {
        left: 24px; /* Mantener posición fija */
    }

    /* Estilos para los botones de llamada flotantes */
    #startCallBtn, #stopCallBtn {
        transition: all 0.3s ease;
        min-width: 200px;
        justify-content: center;
    }

    #startCallBtn:hover, #stopCallBtn:hover {
        transform: translate(-50%, -2px);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    /* Eliminar los estilos anteriores de posicionamiento left */
    /* #startCallBtn, #stopCallBtn {
        left: 96px;
    } */

    /* Asegurar que el texto y el ícono estén alineados correctamente */
    #startCallBtn i, #stopCallBtn i {
        margin-right: 0.5rem;
    }

    /* Estilos para el modo pantalla completa */
    .fullscreen-mode {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 9999;
        background: black;
        padding: 0 !important; /* Eliminar padding */
        margin: 0 !important; /* Eliminar margin */
    }

    .fullscreen-mode .min-h-screen {
        padding: 0 !important;
        margin: 0 !important;
        height: 100vh;
    }

    .fullscreen-mode #videoContainer {
        height: 100vh;
        padding: 0;
        margin: 0;
    }

    .fullscreen-mode #localVideo,
    .fullscreen-mode #remoteVideo {
        height: 100vh;
        width: 100vw;
        object-fit: cover;
    }

    .fullscreen-mode.bg-gray-100 {
        background: black !important;
    }

    .fullscreen-mode > div {
        padding: 0 !important;
        margin: 0 !important;
    }

    /* Ajustar el contenedor de botones en pantalla completa */
    .fullscreen-mode .relative {
        padding: 0 !important;
    }

    .fullscreen-mode #videoContainer {
        height: 100vh;
        padding: 0;
    }

    .fullscreen-mode #localVideo,
    .fullscreen-mode #remoteVideo {
        height: 100vh;
    }

    /* Ajustar posición de botones en modo pantalla completa */
    .fullscreen-mode #fullscreenBtn {
        left: 24px; /* En modo pantalla completa, se alinea con el borde */
        margin-left: 0;
    }

    .fullscreen-mode #fullscreenBtn i {
        transform: rotate(180deg);
    }

    /* Asegurar que los botones flotantes permanezcan visibles */
    .fullscreen-mode #startCallBtn,
    .fullscreen-mode #stopCallBtn,
    .fullscreen-mode #chatToggleBtn,
    .fullscreen-mode #tokenToggleBtn {
        z-index: 10000;
    }

    /* Actualizar estilos del botón de pantalla completa */
    #fullscreenBtn {
        transition: all 0.3s ease;
        z-index: 20;
    }

    #fullscreenBtn:hover {
        transform: scale(1.1);
    }

    .fullscreen-mode #fullscreenBtn {
        bottom: auto; /* Eliminar posición bottom */
        top: 1rem;   /* Posicionar en la parte superior */
        right: 1rem; /* Mantener en la derecha */
        background-color: rgba(0, 0, 0, 0.5); /* Mantener semi-transparente */
        z-index: 10000; /* Asegurar que esté sobre el video */
    }

    /* Actualizar estilos del botón de pantalla completa en modo fullscreen */
    .fullscreen-mode #fullscreenBtn {
        position: absolute;
        top: 1rem;
        left: 50%; /* Centrar horizontalmente */
        transform: translateX(-50%); /* Ajustar la posición para centrado perfecto */
        padding: 0.5rem;
        background-color: rgba(0, 0, 0, 0.5);
        border-radius: 0.375rem;
        width: auto;
        min-width: auto;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
    }

    /* Asegurar que el botón tenga un tamaño específico y esté centrado */
    #fullscreenBtn {
        width: 40px;
        height: 40px;
        padding: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #fullscreenBtn:hover {
        transform: translateX(-50%) scale(1.1); /* Mantener centrado al hacer hover */
    }

    /* Ajustar el contenedor del botón para que no ocupe todo el ancho */
    .fullscreen-mode #fullscreenBtn {
        width: fit-content;
        height: fit-content;
    }

    /* Eliminar estilos que puedan estar causando el problema */
    .fullscreen-mode #fullscreenBtn::before,
    .fullscreen-mode #fullscreenBtn::after {
        display: none;
    }

    /* Asegurar que el botón tenga un tamaño específico */
    #fullscreenBtn {
        width: 40px;
        height: 40px;
        padding: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
</style>

@section Scripts {
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Add WebRTC adapter for browser compatibility -->
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    
    <script>
        let socket = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        const initialOptions = document.getElementById('initialOptions');
        const mainContent = document.getElementById('mainContent');
        const tokenDialog = document.getElementById('tokenDialog');
        const generateBtn = document.getElementById('generateBtn');
        const joinBtn = document.getElementById('joinBtn');
        const cancelJoin = document.getElementById('cancelJoin');
        const confirmJoin = document.getElementById('confirmJoin');
        const tokenInput = document.getElementById('tokenInput');
        const chatBox = document.getElementById("chat-box");
        const chatInput = document.getElementById("chat-input");
        const sendBtn = document.getElementById("send-btn");
        const chatToggleBtn = document.getElementById('chatToggleBtn');
        const chatPanel = document.getElementById('chatPanel');
        const closeChatBtn = document.getElementById('closeChatBtn');
        const unreadBadge = document.getElementById('unreadBadge');
        const tokenToggleBtn = document.getElementById('tokenToggleBtn');
        const tokenPanel = document.getElementById('tokenPanel');
        const closeTokenBtn = document.getElementById('closeTokenBtn');
        const copyTokenBtn = document.getElementById('copyTokenBtn');
        const startCallBtn = document.getElementById("startCallBtn");
        const stopCallBtn = document.getElementById("stopCallBtn");
        const localVideo = document.getElementById("localVideo");
        const remoteVideo = document.getElementById("remoteVideo");

        let unreadCount = 0;
        let isChatOpen = false;
        let isTokenPanelOpen = false;

        // Generate new appointment
        generateBtn.addEventListener('click', async () => {
            initialOptions.classList.add('hidden');
            mainContent.classList.remove('hidden');
            initializeWebSocket("@Model.RoomToken"); // Inicializar WebSocket con el token generado
        });

        // Show token input dialog
        joinBtn.addEventListener('click', () => {
            tokenDialog.classList.remove('hidden');
        });

        // Hide token input dialog
        cancelJoin.addEventListener('click', () => {
            tokenDialog.classList.add('hidden');
            tokenInput.value = '';
        });

        // Join existing appointment
        confirmJoin.addEventListener('click', () => {
            const token = tokenInput.value.trim();
            if (token) {
                window.location.href = `/Principal/CitaVirtual/Index?token=${encodeURIComponent(token)}`;
            } else {
                alert('Por favor ingrese un token válido');
            }
        });

        // Initialize based on URL parameter
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            
            if (token) {
                initialOptions.classList.add('hidden');
                mainContent.classList.remove('hidden');
                initializeWebSocket(token); // Inicializar WebSocket solo si hay token
            }
        });

        // Remover la inicialización inmediata del socket y crear una función para ello

        function initializeWebSocket(token) {
            if (socket && socket.readyState !== WebSocket.CLOSED) {
                socket.close();
            }

            try {
                const protocol = window.location.protocol === "https:" ? "wss://" : "ws://";
                const wsUrl = `${protocol}${window.location.host}/chat?token=${token}`;
                
                console.log("Attempting to connect to:", wsUrl);
                socket = new WebSocket(wsUrl);

                socket.onopen = function() {
                    console.log("WebSocket connection established");
                    chatBox.innerHTML = '';
                    reconnectAttempts = 0; // Reset reconnect attempts on successful connection
                    
                    // Mostrar mensaje de conexión exitosa
                    const message = document.createElement("div");
                    message.textContent = "Conectado a la sala de chat";
                    message.style.textAlign = "center";
                    message.style.color = "green";
                    chatBox.appendChild(message);
                };

                socket.onclose = function(event) {
                    console.log("WebSocket connection closed", event.code, event.reason);
                    if (peerConnection) {
                        stopCall();
                    }

                    // Mostrar mensaje de desconexión
                    const message = document.createElement("div");
                    message.textContent = "Desconectado del chat. Intentando reconectar...";
                    message.style.textAlign = "center";
                    message.style.color = "red";
                    chatBox.appendChild(message);
                    
                    // Intentar reconectar solo si no fue un cierre limpio y no excedimos los intentos
                    if (!event.wasClean && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                        console.log(`Reconnect attempt ${reconnectAttempts + 1} in ${delay}ms`);
                        setTimeout(() => {
                            reconnectAttempts++;
                            initializeWebSocket(token);
                        }, delay);
                    } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                        const message = document.createElement("div");
                        message.textContent = "No se pudo establecer conexión. Por favor, recarga la página.";
                        message.style.textAlign = "center";
                        message.style.color = "red";
                        chatBox.appendChild(message);
                    }
                };

                socket.onerror = function(error) {
                    console.error("WebSocket error:", error);
                    // Mostrar mensaje de error al usuario
                    const message = document.createElement("div");
                    message.textContent = "Error de conexión";
                    message.style.textAlign = "center";
                    message.style.color = "red";
                    chatBox.appendChild(message);
                };

                socket.onmessage = handleSocketMessage;

            } catch (error) {
                console.error("Error creating WebSocket:", error);
                const message = document.createElement("div");
                message.textContent = "Error al crear la conexión";
                message.style.textAlign = "center";
                message.style.color = "red";
                chatBox.appendChild(message);
            }
        }

        // Modify existing WebSocket connection code
        const getToken = () => {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('token') || "@Model.RoomToken";
        };

        // Handle send message and Enter key
        const sendMessage = () => {
            const tryToSend = (retries = 3) => {
                if (!socket || socket.readyState !== WebSocket.OPEN) {
                    if (retries > 0) {
                        setTimeout(() => tryToSend(retries - 1), 1000);
                        return;
                    }
                    alert('No hay conexión activa con la sala de chat');
                    return;
                }
                
                const message = chatInput.value.trim();
                if (message) {
                    try {
                        const prefix = @Json.Serialize(Model.IsAnonymousUser) ? "Tú:" : "chat:";
                        socket.send(prefix + message);
                        chatInput.value = "";
                    } catch (error) {
                        console.error("Error sending message:", error);
                        if (retries > 0) {
                            setTimeout(() => tryToSend(retries - 1), 1000);
                        }
                    }
                }
            };

            tryToSend();
        };

        sendBtn.addEventListener("click", sendMessage);
        chatInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        let localStream;
        let remoteStream;
        let peerConnection;

        // Simplificar la configuración de los servidores ICE
        const servers = {
            iceServers: [
                {
                    urls: 'stun:stun.l.google.com:19302'
                }
            ]
        };

        // Function to stop all tracks and clean up
        function stopCall() {
            try {
                // Función auxiliar para detener tracks
                const stopTracks = (tracks) => {
                    if (tracks) {
                        tracks.forEach(track => {
                            track.enabled = false;
                            track.stop();
                        });
                    }
                };

                // Limpiar video local
                if (localVideo.srcObject) {
                    const tracks = localVideo.srcObject.getTracks();
                    stopTracks(tracks);
                    localVideo.srcObject = null;
                }

                // Limpiar video remoto
                if (remoteVideo.srcObject) {
                    const tracks = remoteVideo.srcObject.getTracks();
                    stopTracks(tracks);
                    remoteVideo.srcObject = null;
                }

                // Limpiar streams
                if (localStream) {
                    stopTracks(localStream.getTracks());
                    localStream = null;
                }

                if (remoteStream) {
                    stopTracks(remoteStream.getTracks());
                    remoteStream = null;
                }

                // Limpiar la conexión peer
                if (peerConnection) {
                    // Detener todos los transceivers
                    const transceivers = peerConnection.getTransceivers();
                    transceivers.forEach(transceiver => {
                        if (transceiver.stop) {
                            transceiver.stop();
                        }
                    });

                    // Detener todos los senders
                    peerConnection.getSenders().forEach(sender => {
                        if (sender.track) {
                            sender.track.stop();
                        }
                    });

                    // Detener todos los receivers
                    peerConnection.getReceivers().forEach(receiver => {
                        if (receiver.track) {
                            receiver.track.stop();
                        }
                    });

                    // Eliminar todas las referencias
                    peerConnection.ontrack = null;
                    peerConnection.onicecandidate = null;
                    peerConnection.oniceconnectionstatechange = null;
                    peerConnection.onsignalingstatechange = null;
                    peerConnection.onicegatheringstatechange = null;
                    peerConnection.onconnectionstatechange = null;
                    
                    peerConnection.close();
                    peerConnection = null;
                }

                // Forzar la recolección de basura
                if (window.gc) {
                    window.gc();
                }

                // Verificación adicional de recursos de medios
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia({ audio: true, video: true })
                        .then(stream => {
                            stopTracks(stream.getTracks());
                        })
                        .catch(() => {});
                }

                // Resetear UI
                startCallBtn.disabled = false;
                startCallBtn.innerHTML = '<i class="fas fa-video mr-2"></i><span>Iniciar Videollamada</span>';
                startCallBtn.style.display = "block";
                stopCallBtn.style.display = "none";

                // Limpiar vista
                const videoContainer = document.getElementById('videoContainer');
                const remoteVideoContainer = document.getElementById('remoteVideoContainer');
                videoContainer.classList.remove('split-view');
                remoteVideoContainer.classList.add('hidden');

                // Limpiar cola de candidatos ICE
                iceCandidatesQueue = [];

            } catch (error) {
                console.error("Error in stopCall:", error);
            }
        }

        // Agregar listeners adicionales para asegurar la limpieza
        window.addEventListener('beforeunload', () => {
            stopCall();
        });

        window.addEventListener('unload', () => {
            stopCall();
        });

        window.addEventListener('pagehide', () => {
            stopCall();
        });

        window.addEventListener('beforeunload', () => {
            stopCall();
            return null;
        });

        window.addEventListener('unload', () => {
            stopCall();
        });

        window.addEventListener('pagehide', () => {
            stopCall();
        });

        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                stopCall();
            }
        });

        // Actualizar el event listener del stopCallBtn
        stopCallBtn.addEventListener("click", () => {
            stopCall();
            
            // Verificación adicional después de un breve delay
            setTimeout(() => {
                if (localVideo.srcObject || remoteVideo.srcObject) {
                    console.warn("Limpieza adicional necesaria...");
                    stopCall();
                    
                    // Forzar la liberación de recursos
                    localVideo.srcObject = null;
                    remoteVideo.srcObject = null;
                    
                    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                        navigator.mediaDevices.getUserMedia({ audio: true, video: true })
                            .then(stream => {
                                stream.getTracks().forEach(track => {
                                    track.stop();
                                });
                            })
                            .catch(() => {});
                    }
                }
            }, 100);
        });

        // Modificar el event listener del startCallBtn
        startCallBtn.addEventListener("click", async () => {
            startCallBtn.disabled = true;
            
            // Asegurarse de que el botón tenga el contenido correcto antes de iniciar
            startCallBtn.innerHTML = '<i class="fas fa-video mr-2"></i><span>Conectando...</span>';
            
            try {
                const constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;

                if (peerConnection) {
                    peerConnection.close();
                }
                setupPeerConnection();

                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                
                await peerConnection.setLocalDescription(offer);
                
                socket.send("webrtc:" + JSON.stringify({
                    type: "offer",
                    offer: peerConnection.localDescription
                }));

                startCallBtn.style.display = "none";
                stopCallBtn.style.display = "block";
            } catch (error) {
                console.error("Error starting video call:", error);
                startCallBtn.disabled = false;
                startCallBtn.innerHTML = '<i class="fas fa-video mr-2"></i><span>Iniciar Videollamada</span>';
                alert("Error al iniciar la videollamada: " + error.message);
            }
        });

        stopCallBtn.addEventListener("click", stopCall);

        // Agregar array para almacenar candidatos ICE pendientes
        let iceCandidatesQueue = [];

        // Actualizar la función setupPeerConnection
        function setupPeerConnection() {
            try {
                if (peerConnection) {
                    peerConnection.close();
                }
                
                peerConnection = new RTCPeerConnection(servers);
                console.log("New peer connection created");

                // Agregar streams al peer connection
                if (localStream) {
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });
                }

                peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        console.log("Sending ICE candidate");
                        sendWebRTCMessage("candidate", {
                            candidate: event.candidate
                        });
                    }
                };

                peerConnection.onconnectionstatechange = () => {
                    console.log("Connection state changed:", peerConnection.connectionState);
                    switch (peerConnection.connectionState) {
                        case "connected":
                            console.log("Successfully connected!");
                            break;
                        case "disconnected":
                        case "failed":
                            console.log("Connection failed, attempting recovery...");
                            handleConnectionFailure();
                            break;
                        case "closed":
                            console.log("Connection closed");
                            break;
                    }
                };

                peerConnection.ontrack = event => {
                    console.log("Received remote track", event.streams[0]);
                    remoteStream = event.streams[0];
                    remoteVideo.srcObject = remoteStream;
                    
                    const videoContainer = document.getElementById('videoContainer');
                    const remoteVideoContainer = document.getElementById('remoteVideoContainer');
                    
                    remoteVideoContainer.classList.remove('hidden');
                    videoContainer.classList.add('split-view');
                };

                return true;
            } catch (error) {
                console.error("Error in setupPeerConnection:", error);
                return false;
            }
        }

        async function handleWebRTCMessage(data) {
            if (data.type === "user-joined") {
                console.log("User joined the call:", data.user);
                // The other user joined, we can now proceed with the WebRTC handshake
            }
            try {
                // Initialize peerConnection if it doesn't exist
                if (!peerConnection) {
                    setupPeerConnection();
                }

                switch (data.type) {
                    case "offer":
                        try {
                            const constraints = {
                                video: {
                                    width: { ideal: 1280 },
                                    height: { ideal: 720 }
                                },
                                audio: {
                                    echoCancellation: true,
                                    noiseSuppression: true,
                                    autoGainControl: true
                                }
                            };

                            if (!localStream) {
                                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                                localVideo.srcObject = localStream;
                                
                                localStream.getTracks().forEach(track => {
                                    peerConnection.addTrack(track, localStream);
                                });
                            }

                            // Primero establecer la descripción remota
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));

                            // Crear y establecer la respuesta
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            
                            // Enviar la respuesta
                            socket.send("webrtc:" + JSON.stringify({
                                type: "answer",
                                answer: peerConnection.localDescription
                            }, null, 0)); // Usar null y 0 para evitar problemas de formato JSON

                            startCallBtn.style.display = "none";
                            stopCallBtn.style.display = "block";

                            // Process any queued candidates
                            while (iceCandidatesQueue.length > 0) {
                                const candidate = iceCandidatesQueue.shift();
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            }
                        } catch (error) {
                            console.error("Error handling offer:", error);
                        }
                        break;

                    case "answer":
                        try {
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                            
                            // Process any queued candidates after setting remote description
                            while (iceCandidatesQueue.length > 0) {
                                const candidate = iceCandidatesQueue.shift();
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            }
                        } catch (error) {
                            console.error("Error setting remote description:", error);
                        }
                        break;

                    case "candidate":
                        try {
                            const candidate = data.candidate;
                            if (peerConnection.remoteDescription) {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                console.log("Added ICE candidate");
                            } else {
                                console.log("Queueing ICE candidate");
                                iceCandidatesQueue.push(candidate);
                            }
                        } catch (error) {
                            console.error("Error handling ICE candidate:", error);
                        }
                        break;
                }
            } catch (error) {
                console.error("Error in handleWebRTCMessage:", error);
            }
        }

        // Add function to join existing call
        async function joinExistingCall(targetUser) {
            try {
                const constraints = {
                    video: true,
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;

                peerConnection = new RTCPeerConnection(servers);
                
                // ...existing WebRTC setup code...

                // Send join message
                socket.send("webrtc:" + JSON.stringify({ 
                    type: "join", 
                    target: targetUser 
                }));

                startCallBtn.style.display = "none";
                stopCallBtn.style.display = "block";
            } catch (error) {
                console.error("Error joining call:", error);
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopCall);

        // Add new chat toggle functionality
        function toggleChat() {
            document.body.classList.toggle('chat-open');
            isChatOpen = !isChatOpen;
            if (isChatOpen) {
                // Reset unread count when opening chat
                unreadCount = 0;
                unreadBadge.classList.add('hidden');
            }
        }

        chatToggleBtn.addEventListener('click', toggleChat);
        closeChatBtn.addEventListener('click', toggleChat);

        // Agregar función para manejar la desconexión
        function handleDisconnection() {
            const videoContainer = document.getElementById('videoContainer');
            const remoteVideoContainer = document.getElementById('remoteVideoContainer');
            
            videoContainer.classList.remove('split-view', 'pip-mode');
            remoteVideoContainer.classList.add('hidden');
        }

        // Función para manejar mensajes del socket
        function handleSocketMessage(event) {
            try {
                // Check if the message is a WebRTC message
                if (event.data.startsWith("webrtc:")) {
                    try {
                        const jsonStr = event.data.substring(7).trim();
                        const data = JSON.parse(jsonStr);
                        if (data && data.type) {
                            handleWebRTCMessage(data);
                        }
                    } catch (error) {
                        console.error("Error parsing WebRTC message:", error);
                        console.log("Raw message:", event.data.substring(7));
                    }
                    return;
                }

                // Handle regular chat messages
                const message = document.createElement("div");
                let messageText = event.data;
                
                if (@Json.Serialize(Model.IsAnonymousUser)) {
                    if (messageText.startsWith("Tú:")) {
                        message.classList.add("sent-by-me");
                    }
                    message.textContent = messageText.startsWith("Tú:") ? 
                        messageText : 
                        "Doctor: " + messageText.split(":")[1];
                } else {
                    message.textContent = messageText;
                }
                
                message.className = "message-bubble";
                chatBox.appendChild(message);
                chatBox.scrollTop = chatBox.scrollHeight;

                // Update unread count if chat is closed
                if (!isChatOpen && !event.data.startsWith('webrtc:')) {
                    unreadCount++;
                    unreadBadge.textContent = unreadCount;
                    unreadBadge.classList.remove('hidden');
                }
            } catch (error) {
                console.error("Error processing message:", error);
            }
        }

        // Add token panel toggle functionality
        function toggleTokenPanel() {
            document.body.classList.toggle('token-open');
            isTokenPanelOpen = !isTokenPanelOpen;
            
            // Solo actualizar el panel, no el botón
            if (isTokenPanelOpen) {
                tokenPanel.style.transform = 'translateX(0)';
            } else {
                tokenPanel.style.transform = 'translateX(-100%)';
            }
        }

        tokenToggleBtn.addEventListener('click', toggleTokenPanel);
        closeTokenBtn.addEventListener('click', toggleTokenPanel);

        // Add copy token functionality
        copyTokenBtn.addEventListener('click', async () => {
            const token = '@Model.RoomToken';
            try {
                await navigator.clipboard.writeText(token);
                
                // Cambiar temporalmente el ícono para dar feedback
                const icon = copyTokenBtn.querySelector('i');
                icon.classList.remove('fa-copy');
                icon.classList.add('fa-check');
                
                setTimeout(() => {
                    icon.classList.remove('fa-check');
                    icon.classList.add('fa-copy');
                }, 2000);
            } catch (err) {
                console.error('Error al copiar el token:', err);
                alert('No se pudo copiar el token. Por favor, cópialo manualmente.');
            }
        });

        // Agregar código para el manejo de pantalla completa
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const mainContentDiv = document.getElementById('mainContent');
        
        fullscreenBtn.addEventListener('click', toggleFullscreen);

        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                // Entrar en modo pantalla completa
                if (mainContentDiv.requestFullscreen) {
                    mainContentDiv.requestFullscreen();
                } else if (mainContentDiv.webkitRequestFullscreen) {
                    mainContentDiv.webkitRequestFullscreen();
                }
                mainContentDiv.classList.add('fullscreen-mode');
                fullscreenBtn.querySelector('i').classList.remove('fa-expand');
                fullscreenBtn.querySelector('i').classList.add('fa-compress');
            } else {
                // Salir del modo pantalla completa
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                mainContentDiv.classList.remove('fullscreen-mode');
                fullscreenBtn.querySelector('i').classList.remove('fa-compress');
                fullscreenBtn.querySelector('i').classList.add('fa-expand');
            }
        }

        // Manejar cambios de estado de pantalla completa
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);

        function handleFullscreenChange() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                mainContentDiv.classList.remove('fullscreen-mode');
                fullscreenBtn.querySelector('i').classList.remove('fa-compress');
                fullscreenBtn.querySelector('i').classList.add('fa-expand');
            }
        }

        // Agregar función para procesar la cola de candidatos ICE
        async function processIceCandidateQueue() {
            if (peerConnection.remoteDescription && iceCandidatesQueue.length > 0) {
                console.log("Processing queued ICE candidates");
                try {
                    while (iceCandidatesQueue.length > 0) {
                        const candidate = iceCandidatesQueue.shift();
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log("Successfully added queued ICE candidate");
                    }
                } catch (error) {
                    console.error("Error processing ICE candidate queue:", error);
                }
            }
        }

        // Función auxiliar para enviar mensajes WebRTC de forma segura
        function sendWebRTCMessage(type, data) {
            try {
                const message = {
                    type: type,
                    ...data
                };
                const jsonString = JSON.stringify(message, null, 0);
                socket.send("webrtc:" + jsonString);
            } catch (error) {
                console.error("Error sending WebRTC message:", error);
            }
        }

        // Actualizar setupPeerConnection
        function setupPeerConnection() {
            try {
                if (peerConnection) {
                    peerConnection.close();
                }
                
                peerConnection = new RTCPeerConnection(servers);
                console.log("New peer connection created");

                peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        console.log("Sending ICE candidate");
                        sendWebRTCMessage("candidate", {
                            candidate: event.candidate
                        });
                    }
                };

                peerConnection.ontrack = event => {
                    console.log("Received remote track");
                    if (event.streams && event.streams[0]) {
                        remoteVideo.srcObject = event.streams[0];
                        remoteStream = event.streams[0];
                        
                        const videoContainer = document.getElementById('videoContainer');
                        const remoteVideoContainer = document.getElementById('remoteVideoContainer');
                        
                        remoteVideoContainer.classList.remove('hidden');
                        videoContainer.classList.add('split-view');
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    console.log("ICE Connection State:", peerConnection.iceConnectionState);
                    if (peerConnection.iceConnectionState === 'failed') {
                        handleConnectionFailure();
                    }
                };

                return true;
            } catch (error) {
                console.error("Error in setupPeerConnection:", error);
                return false;
            }
        }

        // Agregar función para manejar fallos de conexión
        function handleConnectionFailure() {
            console.log("Connection failed, attempting recovery...");
            if (peerConnection) {
                try {
                    peerConnection.restartIce();
                    setTimeout(() => {
                        if (peerConnection.iceConnectionState === 'failed') {
                            console.log("Recovery failed, resetting connection...");
                            stopCall();
                            alert("La conexión se ha perdido. Por favor, intente nuevamente.");
                        }
                    }, 5000);
                } catch (error) {
                    console.error("Error in handleConnectionFailure:", error);
                }
            }
        }

        // Actualizar el startCallBtn click handler
        startCallBtn.addEventListener("click", async () => {
            startCallBtn.disabled = true;
            startCallBtn.innerHTML = '<i class="fas fa-video mr-2"></i><span>Conectando...</span>';
            
            try {
                const constraints = {
                    video: true,
                    audio: true
                };

                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                localVideo.srcObject = localStream;

                if (setupPeerConnection()) {
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });

                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    
                    sendWebRTCMessage("offer", {
                        offer: peerConnection.localDescription
                    });

                    startCallBtn.style.display = "none";
                    stopCallBtn.style.display = "block";
                } else {
                    throw new Error("Failed to setup peer connection");
                }
            } catch (error) {
                console.error("Error starting video call:", error);
                startCallBtn.disabled = false;
                startCallBtn.innerHTML = '<i class="fas fa-video mr-2"></i><span>Iniciar Videollamada</span>';
                alert("Error al iniciar la videollamada: " + error.message);
            }
        });

        // Actualizar handleWebRTCMessage
        async function handleWebRTCMessage(data) {
            try {
                if (!peerConnection || peerConnection.connectionState === 'closed') {
                    setupPeerConnection();
                }

                switch (data.type) {
                    case "offer":
                        try {
                            if (!localStream) {
                                localStream = await navigator.mediaDevices.getUserMedia({
                                    video: true,
                                    audio: true
                                });
                                localVideo.srcObject = localStream;
                                localStream.getTracks().forEach(track => {
                                    peerConnection.addTrack(track, localStream);
                                });
                            }

                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            
                            sendWebRTCMessage("answer", {
                                answer: answer
                            });

                            startCallBtn.style.display = "none";
                            stopCallBtn.style.display = "block";

                            // Process any queued candidates
                            while (iceCandidatesQueue.length > 0) {
                                const candidate = iceCandidatesQueue.shift();
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            }
                        } catch (error) {
                            console.error("Error handling offer:", error);
                        }
                        break;

                    case "answer":
                        try {
                            await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                            
                            // Process any queued candidates after setting remote description
                            while (iceCandidatesQueue.length > 0) {
                                const candidate = iceCandidatesQueue.shift();
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            }
                        } catch (error) {
                            console.error("Error setting remote description:", error);
                        }
                        break;

                    case "candidate":
                        try {
                            const candidate = data.candidate;
                            if (peerConnection.remoteDescription) {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                console.log("Added ICE candidate");
                            } else {
                                console.log("Queueing ICE candidate");
                                iceCandidatesQueue.push(candidate);
                            }
                        } catch (error) {
                            console.error("Error handling ICE candidate:", error);
                        }
                        break;
                }
            } catch (error) {
                console.error("Error in handleWebRTCMessage:", error);
            }
        }

        // Actualizar la función handleSocketMessage
        function handleSocketMessage(event) {
            try {
                if (event.data.startsWith("webrtc:")) {
                    const jsonStr = event.data.substring(7).trim();
                    try {
                        const data = JSON.parse(jsonStr);
                        if (data && data.type) {
                            handleWebRTCMessage(data);
                        }
                    } catch (error) {
                        console.error("Error parsing WebRTC message:", error);
                        console.error("Raw message:", jsonStr);
                    }
                    return;
                }
                // Handle regular chat messages
                const message = document.createElement("div");
                let messageText = event.data;
                
                if (@Json.Serialize(Model.IsAnonymousUser)) {
                    if (messageText.startsWith("Tú:")) {
                        message.classList.add("sent-by-me");
                    }
                    message.textContent = messageText.startsWith("Tú:") ? 
                        messageText : 
                        "Doctor: " + messageText.split(":")[1];
                } else {
                    message.textContent = messageText;
                }
                
                message.className = "message-bubble";
                chatBox.appendChild(message);
                chatBox.scrollTop = chatBox.scrollHeight;

                // Update unread count if chat is closed
                if (!isChatOpen && !event.data.startsWith('webrtc:')) {
                    unreadCount++;
                    unreadBadge.textContent = unreadCount;
                    unreadBadge.classList.remove('hidden');
                }
            } catch (error) {
                console.error("Error processing message:", error);
            }
        }
    </script>
}

